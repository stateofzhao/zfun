/**下载项目的maven依赖，然后转存到指定目录（相当于将依赖拉取下来后放到本地maven仓库）。*/

//fixme lzf 会对传递依赖中的相同依赖进行重复拉取，后续可以优化掉

/*apply plugin:'java' //so that I can use 'implementation', 'compileClasspath' configuration；申请此插件后可以访问 ConfigurationContainer#implementation,ConfigurationContainer#compileClasspath
//编译环境
java {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}*/

import org.gradle.internal.component.external.model.DefaultModuleComponentIdentifier
import org.gradle.api.internal.artifacts.DefaultModuleIdentifier
import org.gradle.util.GFileUtils

//配置项 ============================================================================================ start
def outputPath = rootProject.projectDir.parent+'/offlineDepdencies/maven'

def includeSources = true
def includeJavadocs = true
def includeMavenPom = true

def includeBuildscriptDependencies = true //是否包含构建脚本的依赖

def cleanOutputPath = true  //是否清空依赖输出目录

def includeProjectNames = []//要拉取的项目；默认拉取所有项目
def includeConfigurationNames = []//要拉取的依赖类型，默认拉取所有，例如：implementation,compileOnly等
def includeGroupNames = []//要拉取的依赖的group，采用String.contains进行判断，所以可以仅设置group中的部分字符；默认会全部拉取
//配置项 ============================================================================================ end


//Task闭包中直接编写的代码，会在配置阶段执行。可以通过doFirst、doLast块将代码逻辑放到执行阶段中执行
//Exec类型的task，也即是此task继承自ExecTask
task downloadDependencies() {
    //读取配置
    doFirst {
        def EMPTY_DEPENDENCIES_ARRAY = new Dependency[0]

        def Map<ModuleComponentIdentifier,Set<File>> repositoryFiles = [:]//外部依赖module包含的文件
        def Set<ConfigurationWrapper> projectConfigurations = []
        def Set<RepositoryWrapper> projectRepositories = []

        trace("##################################【downloadDependencies】任务 ################################## 开始",0)

        trace("==================配置==================",1)
        trace("outputPath：                      $outputPath",2)
        trace("includeSources：                  $includeSources",2)
        trace("includeJavadocs：                 $includeJavadocs",2)
        trace("includeMavenPom：                 $includeMavenPom",2)
        trace("includeBuildscriptDependencies：  $includeBuildscriptDependencies",2)
        trace("cleanOutputPath：                 $cleanOutputPath",2)
        trace("includeProjectNames：             $includeProjectNames",2)
        trace("includeConfigurationNames：       $includeConfigurationNames",2)
        trace("includeGroupNames：               $includeGroupNames",2)
        trace("==================配置==================",1)

        //读取配置项
        gradle.allprojects{ project ->
            //项目依赖
            if (includeProjectNames?.empty || includeProjectNames.contains(project.name)) {
                def projectConfigWrapper = null
                if (includeConfigurationNames?.empty) {
                    projectConfigWrapper = createConfigurationWrapper(project,project.configurations)
                } else {
                    def projectConfigs = []
                    includeConfigurationNames.forEach { name ->
                        projectConfigs.add(project.configurations.getByName(name))
                    }
                    projectConfigWrapper = createConfigurationWrapper(project,projectConfigs)
                }
                //项目buildscript依赖
                if (includeBuildscriptDependencies) {
                    if (null == projectConfigWrapper) {
                        projectConfigWrapper = createConfigurationWrapper(project,project.buildscript.configurations)
                    } else {
                        projectConfigWrapper.appendConfigurations(project,project.buildscript.configurations)
                    }
                }
                if (null != projectConfigWrapper) {
                    projectConfigurations.add(projectConfigWrapper)
                }
            }
            //配置project的依赖仓库，因为project的依赖仓库是不带buildscript的依赖仓库的，所以这里需要给它们加上
            def oriRepositories = project.repositories
            def oriBuildscriptRep = project.buildscript.repositories
            project.repositories.addAll(oriBuildscriptRep)
            projectRepositories.add(new RepositoryWrapper(oriRepositories,project))
        }//allprojects

        //根据配置拉取依赖
        if (projectConfigurations?.empty){
            trace("无需拉取依赖",1)
            return
        }
        for (configWrapper in projectConfigurations) {
            def Set<Configuration> configurations = configWrapper.configurations
            def Project project = configWrapper.project
            trace("【${project.name}】项目下载依赖 ============================== start",1)
            for (aConfiguration in configurations){
                trace("【${aConfiguration.name}】配置拉取 ================ start",2)
                for (dependency in aConfiguration.allDependencies){
                    Set<ModuleComponentIdentifier> componentIds = new HashSet<>()
                    if (dependency instanceof ExternalModuleDependency){//外部依赖（maven库，libs中的依赖等） //只处理外部依赖
                        if (null==dependency.module.group){//fixme lzf 本地libs目录下的依赖，group为null（先暂时这么用，以后找到更好的方式时再修改）
                            trace("忽略本地libs下依赖：$dependency.module.name",3)
                            continue
                        } else {
                            trace("开始拉取依赖：$dependency.module.group:$dependency.module.name:$dependency.version",3)
                        }
                        //step 1 获取module信息以及module的artifact文件
                        //detachedConfiguration 为每个依赖项创建一个分离的配置，以获取依赖项的所有声明版本，否则只会拉取到最新的版本
                        def configurationCopy = project.configurations.detachedConfiguration([dependency].toArray(EMPTY_DEPENDENCIES_ARRAY))
                        if (configurationCopy.resolvedConfiguration.hasError()){
                            trace("无法解析此依赖！",3)
                            continue
                        }
                        configurationCopy.resolvedConfiguration.resolvedArtifacts.forEach{
                            def componentId = DefaultModuleComponentIdentifier.newId(DefaultModuleIdentifier.newId(it.moduleVersion.id.group, it.moduleVersion.id.name), it.moduleVersion.id.version)
                            def skip = isNeedSkipFetch(includeGroupNames,it.moduleVersion.id)
                            if (skip){
                                trace("由于配置，忽略此依赖：",componentId,null,4)
                            } else {
                                componentIds.add(componentId)
                                addToMultimap(repositoryFiles,componentId,it.file)//it.file 为jar，aar等
                                trace("添加依赖：",componentId,it.file,4)
                            }
                        }//end forEach

                        //step 2 获取module的 sources 和 javadocs
                        if ((includeSources || includeJavadocs) && !componentIds.empty){
                            trace("收集Java源码和Java文档",4)
                            def jvmArtifacts = project.dependencies.createArtifactResolutionQuery()
                                    .forComponents(componentIds)
                                    .withArtifacts(JvmLibrary, SourcesArtifact, JavadocArtifact)
                                    .execute()//查询远程module仓库
                            for (component in jvmArtifacts.resolvedComponents){
                                if (includeSources){
                                    def sources = component.getArtifacts(SourcesArtifact)
                                    if (!sources?.empty){
                                        sources.forEach({
                                            def file = (it as ResolvedArtifactResult).file
                                            addToMultimap(repositoryFiles,component.id,file)
                                            trace("添加依赖源码：",component.id,file,4)
                                        })
                                    }
                                }

                                if (includeJavadocs){
                                    def javadocs = component.getArtifacts(JavadocArtifact)
                                    if (!javadocs?.empty){
                                        javadocs.forEach{
                                            def file = (it as ResolvedArtifactResult).file
                                            addToMultimap(repositoryFiles,component.id,file)
                                            trace("添加依赖文档：",component.id,file,4)
                                        }
                                    }
                                }
                            }
                        }//end if(includeSources || includeJavadocs)

                        //step 3 添加maven pom
                        if (includeMavenPom && !componentIds.empty){
                            trace("收集maven pom 文档",4)
                            def mavenArtifacts = project.dependencies.createArtifactResolutionQuery()
                                    .forComponents(componentIds)
                                    .withArtifacts(MavenModule, MavenPomArtifact)
                                    .execute()
                            for (component in mavenArtifacts.resolvedComponents){
                                def pomResults = component.getArtifacts(MavenPomArtifact)
                                if (pomResults?.empty) {
                                    continue
                                }

                                for (pomArtifact in pomResults){
                                    if (pomArtifact instanceof UnresolvedArtifactResult){
                                        trace("Resolver was unable to resolve artifact:${pomArtifact.id} failMsg:{$pomArtifact.getFailure()}",4)
                                        break
                                    }
                                    def pomFile = (pomArtifact as ResolvedArtifactResult).file
                                    addToMultimap(repositoryFiles,component.id,pomFile)
                                    trace("添加MavenPom文档：",component.id,pomFile,4)
                                }
                            }
                        }//end if(includeMavenPom){}
                    } else if (dependency instanceof FileCollectionDependency){//包括：本地SDK依赖，例如，Android32；本地libs下的jar依赖；不包括：本地libs下的aar(本地libs下的aar依赖最终会解析为 ExternalModuleDependency)
                        dependency.files.forEach{
                            trace("本地依赖忽略："+it.path,3)
                        }
                    } else if (dependency instanceof ProjectDependency){//本地project依赖：implementation project(':projectA')
                        trace("本地project依赖忽略："+dependency.dependencyProject,3)
                    }
                }//end for 解析配置项的依赖：implementation ,compileOnly等
                trace("【${aConfiguration.name}】配置拉取 ================ end",2)
            }
            trace("【${project.name}】项目下载依赖 ============================== end",1)
        }//end for 解析所有依赖

        printoutDependencies(cleanOutputPath,outputPath,repositoryFiles)
        //还原project的repository
        projectRepositories.forEach {
            it.project.repositories.clear()
            it.project.repositories.addAll(it.repositoryHandler)
        }
        trace("################################## 【downloadDependencies】任务 ################################## 结束",0)
    }//doFirst

    onlyIf{
        true //即使为true也不会在构建时执行，因为他是一个单独的task，并没有依赖构建过程中的task
    }
}

static <K,V> void addToMultimap(Map<K,Set<V>> map, K key, V value){
    if (!map.containsKey(key)){
        map.put(key,[] as Set<V>)
    }
    map.get(key).add(value)
}

// Return the offline-repository target directory for the given component (naming follows maven conventions)
static File moduleDirectory(String outputPath,ModuleComponentIdentifier ci) {
    new File(outputPath, "${ci.group.tokenize(".").join("/")}/${ci.module}/${ci.version}")
}

static boolean isNeedSkipFetch(List<String> groupNames,ModuleVersionIdentifier identifier){
    if (groupNames?.empty){
        return false
    } else {
        def groupName = identifier.group
        if (null == groupName){
            groupName = ""
        }
        for (it in groupNames){
            if (groupName.toLowerCase().contains(it.toLowerCase())){
                return false
            }
        }
        return true
    }
}

static ConfigurationWrapper createConfigurationWrapper(Project project,Set<Configuration> configurations){
    if(null == project || configurations?.empty){
        return null
    }
    def configSet = new HashSet()
    configurations?.forEach{
        if (!(it?.allDependencies?.empty)){
            configSet.add(it)
        }
    }
    return new ConfigurationWrapper(project,configSet)
}

static def printoutDependencies(boolean cleanOutputPath,String outputPath,Map<ModuleComponentIdentifier,Set<File>> repositoryFiles){
    if (cleanOutputPath){
        trace("清空依赖输出目录：$outputPath",1)
        GFileUtils.deleteDirectory(new File(outputPath))
    }
    trace("开始输出依赖到指定目录：$outputPath",1)
    if (repositoryFiles?.isEmpty()){
        return
    }
    def keys = repositoryFiles.keySet()
    for (ModuleComponentIdentifier id in keys){
        def files = repositoryFiles.get(id)
        def dir = moduleDirectory(outputPath,id)
        GFileUtils.mkdirs(dir)
        files.forEach{file->
            GFileUtils.copyFile(file,new File(dir,file.name))
        }
    }
}

static def trace(String msg,int indentation){
    def strBuild = new StringBuilder()
    for (int i =0;i<indentation;i++){
        strBuild.append('>')
    }
    if (strBuild.length() > 0) {
        strBuild.append(' ')
    }
    strBuild.append(msg)
    println strBuild.toString()
}

static def trace(String pre, ComponentIdentifier componentIdentifier, File file, int indentation) {
    def fileMsg
    if (null != file){
        fileMsg = " == 文件路径${file.getAbsoluteFile()}"
    }else {
        fileMsg = ""
    }
    def msg = ""
    if (componentIdentifier instanceof DefaultModuleComponentIdentifier) {
        def id = componentIdentifier as DefaultModuleComponentIdentifier
        msg = pre + "${id.group}:${id.module}:${id.version}$fileMsg"
    } else {
        msg = pre + "${componentIdentifier.displayName}$fileMsg"
    }
    trace(msg , indentation)
}

//
class ConfigurationWrapper{
    def Set<Configuration> configurations
    def Project project
    ConfigurationWrapper(Project proj,Set<Configuration> confs){
        this.project = proj
        this.configurations = confs
    }

    def appendConfigurations(Project proj,Set<Configuration> confs){
        if (project == proj){
            if (!confs?.empty){
                def configSet = []
                confs.forEach{
                    if (!it.allDependencies?.empty){
                        configSet.add(it)
                    }
                }
                configurations?.addAll(configSet)
            }
        }
    }
}//class ConfigurationWrapper end

class RepositoryWrapper{
    def RepositoryHandler repositoryHandler
    def Project project
    RepositoryWrapper(RepositoryHandler repository,Project proj){
        repositoryHandler = repository
        project = proj
    }
}//class RepositoryWrapper end


//Copy类型的task，也即是此task继承自CopyTask
/*task cacheToMavenLocal(type: Copy) {
    from new File(gradle.gradleUserHomeDir, "caches/modules-2/files-2.1")
    into repositories.mavenLocal().url //本地maven仓库，此处为默认路径:{user_space}/.m2/repository/
    eachFile {
        List<String> parts = it.path.split("/")
        it.path = [parts[0].replace(".","/"), parts[1], parts[2], parts[4]].join("/")
    }
    includeEmptyDirs false
    setDuplicatesStrategy(DuplicatesStrategy.EXCLUDE)
}*/

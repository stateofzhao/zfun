plugins {
    id 'com.android.library' apply true
}

// module 有 productFlavors 时，引用它的 module 也必须有同名的 productFlavors，并且要有同名的 flavorDimensions！
// 所以如果 module 作为 library 的话一般不写 productFlavors。
//
//Gradle 会根据您的buildType{}和productFlavors自动创建构建变体，
// 并按照 <product-flavor><Build-Type> 的格式命名这些变体
android {
    compileSdkVersion rootProject.ext.compileSdkVersion
    buildToolsVersion rootProject.ext.buildToolsVersion

    //定义纬度（可以把他想像成二/三。。。维坐标系，X轴为learn，Y轴为sdk，Z轴。。。），所有productFlavors必须属于一个纬度，
    // 最终组合包必须为纬度的交叉点！
    //flavorDimensions "learn,sdk"//com.android.tools.build:gradle 版本3.0+的时候 配置了 productFlavors 时必须配置这个

    //所有 productFlavor 的基类
    defaultConfig {
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
    }

    //Android Build Variants = productFlavor（纬度交叉点，本例中有两个纬度，那么此处必须是learnSDK或者FullSDK） + buildType；
    // 比如 learnDebug 就表示采用 productFlavors.learn + buildTypes+debug 的配置来构建.
    /*productFlavors {
        learn {
            dimension "learn"
        }

        Full {
            dimension "learn"
        }

        SDK {
            dimension "sdk"
        }
    }*/

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }

        debug {
            minifyEnabled false
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    androidTestImplementation(androidxTestEspresso, {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    implementation project(":zfunlib")
    implementation androidxAppCompat
    implementation androidxRecyclerView
    testImplementation junit
}
